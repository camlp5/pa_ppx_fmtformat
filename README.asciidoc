`pa_ppx_fmtformat version 0.01`: `Fmt`-based string-interpolation
=================================================================
:toc:
:toc-placement: preamble

This package provides a PPX extension for string-interplation, that
expands into `Fmt`-based code.

`[%fmt_str {|a b $(c) d e|}]`::

This can be used anywhere an expression can be used.  The payload must
be a string literal.  In that string literal, 

== Installation and Invocation

To install this package via opam:
```
opam install pa_ppx_fmtformat
```

to build and install, once `pa_ppx` is installed, `make sys test` will do the rest.

=== In the OCaml toplevel

```ocaml
# #use "topfind.camlp5";;
- : unit = ()
Findlib has been successfully loaded. Additional directives:
  #require "package";;      to load a package
  #list;;                   to list the available packages
  #camlp4o;;                to load camlp4 (standard syntax)
  #camlp4r;;                to load camlp4 (revised syntax)
  #predicates "p,q,...";;   to set these predicates
  Topfind.reset();;         to force that packages will be reloaded
  #thread;;                 to enable threads

- : unit = ()
Additional Camlp5 directives:
  #camlp5o;;                to load camlp5 (standard syntax)
  #camlp5r;;                to load camlp5 (revised syntax)

- : unit = ()
# #camlp5o ;;
: added to search path
: added to search path
: loaded
: added to search path
: loaded
# #require "camlp5.pr_o";;
# #require "pa_ppx_fmtformat" ;;
```

== Examples

```ocaml
# let c = "argle"
# let x = [%fmt_str {|a b $(c) d e|}] ;;
val x : string = "a b argle d e|"
```

== Syntax of interpolation text

The contents of the string in `[%fmt_str <string>]` consist in either
plain text, or interpolated expressions.

=== Plain text

Plain text is anything other than '$'.  To express a '$', double it, viz. '$$'.

=== Interpolated expressions

The simplest interpolated expression is of the form `$(...)` but all of the following are accepted:

* `$(...)`,  `$(|...|)`
* `$[...]`,  `$[|...|]`
* `${...}`,  `${|...|}`
* `$<...>`,  `$<|...|>`

So basically, '$' followed by any of [ '(', '[', '{', '<' ],
optionally '|', and then at the end, the matching text.  Between these
8 forms, it should be possible to enclose any interpolated expression
without difficulty, I would think.

In the text surrounded by these delimiter, anything other than the
end-string is acceptable, and there is no provision made for escaping.

The contents of the interpolated expression can be of three forms:

==== interpolated expression with format-specifier

an interpolated expression of the form `$(abc|%d)` specifies that the
expression `abc` will be formatted with `%d`.  So `{%fmt_str|a $(abc|%d)|}` expands to
`Fmt.(str "a %d" abc)`.

==== interpolated expression with Fmt formatter

an interpolated expression of the form `$(abc|int)` specifies that the
expression `abc` will be formatted with the Fmt formatter `int`.  So `{%fmt_str|a $(abc|int)|}` expands to
`Fmt.(str "a %a" int abc)`.

==== interpolated expression without specifier/formatter

an interpolated expression of the form `$(abc)` specifies that the
expression `abc` will be formatted with `%s`.  So `{%fmt_str|a $(abc)|}` expands to
`Fmt.(str "a %s" abc)`.

==== A word about whitespace in interpolated expressions

An interpolated expression consists in either two parts (separated by
'|') or one part (with no '|' present).  In either case,
leading/trailing whitespace in the parts is ignored/removed before
further processing.  Internal whitespace is preserved.